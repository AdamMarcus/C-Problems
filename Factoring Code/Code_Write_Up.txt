HW 8 Write-up
Adam Austin

Overview:
I found this assignment to be very mentally stimulating. For the first week and a half of this assignment, I tried to implement my own entirely original solution to the factoring problem using the tools in my programing toolbox, and to no avail. As a CSCI major and not a mathematician or statistician, my implementation relied only on writing a somewhat efficient algorithm that heightened my odds of finding the right number, but essentially built off of the brute force approach. After failing to maintain adequate results with this approach, I adapted the Pollards Rho algorithm into my code which ran amazingly fast when approaching larger numbers.

Pollards Rho Approach
The pollards Rho algorithm builds off a couple different mathematical facts to search for a factor of any positive integer N. It finds the factor by producing two somewhat random numbers a and b less than N, finding the positive difference of the two, and checking for a Greatest Common Divisor of this difference and N. If a GCD exists, we know that GCD is a factor of N.
The first mathematical tool this function uses is called the Birthday Paradox. This paradox states that when searching for a specific unknown number in a set, while choosing one number at random will result in odds of 1/(size of the set), if instead you chose two random numbers within the range of the set, and guess the difference of the two your odds are much greater of finding the desired number. Logically, this is because with a single guess, there is only one correct answer, but when taking the difference there are many combinations of numbers in the range of the set whose difference is equal to the number you are looking for. To take advantage of this paradox, we calculate two numbers and use their difference to help find a divisor of N.
In the function, the value of b is run through the value-dispersion function two times for every time the value of a is run through the function.  The numbers will be progressing through a predictable series of numbers, and since the variable b is progressing at twice the rate, we can confidently exit the loop if its value is equal to a as this is an indicator b has already covered every possible value at least once.

Adamâ€™s Original Brute Force Approach
Before I surrendered to using the Pollards Rho algorithm, I spent time trying to develop a brute force algorithm that would achieve sufficient results. This involved writing a good amount of supporting code around the algorithm to do things like write large lists of prime numbers and approximate square roots of arbitrarily large numbers. The strategy was largely based around using a relatively large list of known prime numbers to quickly find smaller factors of numbers, and if none are found, setting a large number of intervals between the largest prime in the list and the square root of the number, and checking a value offset from each interval until the factor was found.
First I had code that would write a large list of primes if no file was available, and if one was available, read from the known list of primes. For the start of the algorithm it would simply loop over this list of primes (I used a list of the first 1 million prime numbers during most of my development) and hopefully find a small factor to the number.
If this did not work, the function would use the number of digits in the provided number to determine a large number of intervals to be used in finding the factor. An interval size will be calculated by finding the difference between the largest prime in the list and the root of the number to factor and dividing by the number of intervals. An array is made the size of the number of intervals, and at each index the a value is placed as a sort of checkpoint to check near, in essence this allows the function to check numbers spread out between the largest prime and the root. At this point the function just increases an offset value that it adds to every interval value stored in the array, and loops until the offset value is equal to the distance between intervals, verifying every value has been checked. The worst case is that the factor is two less than the largest multiple of the interval size plus the largest prime. The function will be inefficient where the value is slightly less than any of the interval/checkpoint values, but since there are so many, the odds are higher that the factor will be encountered quickly.
